<body></body>
<script src="https://unpkg.com/tone"></script>
<script src="https://cdn.jsdelivr.net/gh/netizenorg/netnet-standard-library/build/nn.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://algorithmicmusic.online/js/create-spectrum.js"></script>
<script src="https://algorithmicmusic.online/js/create-waveform.js"></script>
<script>
/* global Tone, nn, d3, createWaveform, createSpectrum */
/*
  The example below assumes you've connected a [KORG nanoKONTROL](https://www.korg.com/us/products/computergear/nanokontrol2/) MIDI controller to your computer, and uses the first two knobs and sliders to control the parameters of the Phaser effect.

  NOTE: this works on Chrome, but sadly not on Firefox
*/

const wave = createWaveform()
const spec = createSpectrum({ range: [20, 7040] })
const baseFreq = 440; // Base frequency (A3)
const harmonics = [1, 2, 3, 4, 5]; // First 5 harmonics
const gains = {}; // Store gain nodes
const harmonicGains = new Array(harmonics.length).fill(0);
const oscillators = {}; // Store oscillators
let totalPotential = 1; // Initialize total potential at 1

// Create multiple oscillators for harmonics
harmonics.forEach((multiplier, index) => {
    const osc = new Tone.Oscillator({
        frequency: baseFreq * multiplier,
        type: "sine"
    });

    // Create gain node for amplitude control
    const gain = new Tone.Gain(0); // Start with volume at 0
    osc.connect(gain);
    // osc.toDestination()
    gain.toDestination(); // Send to output
    gain.connect(wave)
    gain.connect(spec)

    // Store oscillator and gain node
    oscillators[index] = osc;
    gains[index] = gain;
});

// Function to start a specific harmonic
function startHarmonic(index) {
    if (oscillators[index]) {
        oscillators[index].start();
    }
}

// Function to stop a specific harmonic
function stopHarmonic(index) {
    if (oscillators[index]) {
        oscillators[index].stop();
    }
}

// Function to start all harmonics
function startAll() {
  // console.log(oscillators)
    Object.values(oscillators).forEach(osc => osc.start());
}

// Function to stop all harmonics
function stopAll() {
    Object.values(oscillators).forEach(osc => osc.stop());
}

// navigator.requestMIDIAccess().then((access) => {
//   // Get lists of available MIDI controllers
//   const inputs = access.inputs.values();
//   const outputs = access.outputs.values();
//   for inp in inputs
// });

function initializeMidiState(midiAccess) {
    const inputs = midiAccess.inputs.values();
    // console.log(inputs)
    for (let input of inputs) {
        // input.addEventListener("midimessage", updateEffect); // Listen for changes
        if (input.chl === 1) {
          console.log('works')
        }
    }
}

// MIDI Control - Adjust Harmonic Amplitudes
// MIDI Control - Adjust Harmonic Amplitudes

// function updateEffect(msg) {
//     if (msg.chl >= 1 && msg.chl <= harmonics.length) {
//         const harmonicIndex = msg.chl - 1; // Map MIDI Channel 1-5 to harmonics 0-4
//         const newAmplitude = msg.val / 127; // Scale MIDI value (0-127) to (0-1)

//         // Set the new amplitude for the current harmonic
//         harmonicGains[harmonicIndex] = newAmplitude;

//         // Recalculate all the gains based on totalPotential and the sum of previous gains
//         let sumUsed = 0; // Tracks the sum of the amplitudes of the previous harmonics

//         // Recalculate the gain for each harmonic
//         for (let i = 0; i < harmonicGains.length; i++) {
//             // Sum all the amplitudes up to the current index
//             if (i < harmonicIndex) {
//                 sumUsed += harmonicGains[i];
//             }
//             // Calculate the new gain for the current harmonic
//             let newGain = totalPotential - sumUsed;
//             // Ensure the gain is not negative
//             if (newGain < 0) {
//                 newGain = 0;
//             }
//             // Update the gain node with the recalculated gain
//             gains[i].gain.setValueAtTime(newGain, Tone.now());
//         }
//     }
// }

function updateEffect(msg) {
  if (msg.chl === 41) { // to start/stop the Osc
    console.log('start?')
    if (msg.val === 127) startAll()
    else if (msg.val === 0) stopAll()
  }
  if (msg.chl >= 0 && msg.chl <= harmonics.length) {
      const harmonicIndex = msg.chl; // Map MIDI Channel 1-5 to harmonics 0-4
      let sumUsed = 0; // Track how much potential is used

      // Calculate total used potential from sliders 0 to current
      for (let i = 0; i < harmonicIndex; i++) {
          sumUsed += (gains[i]?.gain.value || 0);
      }

      // Calculate new gain as total potential minus used sum
      let newGain = totalPotential - (msg.val / 127) - sumUsed;

      // Ensure gain is never below zero
      if (newGain <= 0) newGain = 0

      // Set the new gain for the harmonic
      console.log(gains[0].gain.value, gains[1].gain.value, gains[2].gain.value)
      gains[harmonicIndex].gain.setValueAtTime(newGain, Tone.now());
  }
}

// function updateEffect(msg) {
//   if (msg.chl === 41) { // to start/stop the Osc
//     if (msg.val === 127) startAll()
//     else if (msg.val === 0) stopAll()
//   }
//   if (msg.chl >= 0 && msg.chl <= harmonics.length-1) {
//       const harmonicIndex = msg.chl; // Map MIDI Channel 1-5 to harmonics 0-4
//       const newGain = msg.val / 127; // Scale MIDI value (0-127) to (0-1)
//       // const a = nn.map(msg.val, 1, 126, 1, 20)
//       // console.log(a)
//       // gain.set({ frequency: f })

//       // Set the gain value for the corresponding harmonic
//       // gains[harmonicIndex].gain.set({gain: newGain})
//       gains[harmonicIndex].gain.setValueAtTime(newGain, Tone.now())
//   }
// }

nn.create('button')
  .content('start')
  .addTo('body')
// Example usage:
// startHarmonic(2); // Starts the 3rd harmonic (index 2)
// stopHarmonic(0); // Stops the fundamental (index 0)
// startAll(); // Starts all harmonics
// stopAll(); // Stops all harmonics

console.log('hi')
navigator.requestMIDIAccess().then(initializeMidiState);
nn.MIDI(updateEffect)

</script>